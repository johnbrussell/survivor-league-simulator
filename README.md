This repository generates simulated NFL schedules and survivor league pools.  

# Overview

The class `ScheduleGenerator` generates a simulated schedule of type `Schedule`:
```python
from survivor_league.schedule_generator import ScheduleGenerator
schedule_generator = ScheduleGenerator()
schedule = schedule_generator.generate_schedule()
```

The following code instantiates a simulated survivor league (note that a `League` requires an argument of type `Schedule`):
```python
from survivor_league.league import League
league = League(num_players=15, schedule=schedule)
```

To simulate a season of a `League`, call `simulate_season()`.  To access information about the outcome of the season, utilize the public methods on the `Player` class. 

# Players
During instantiation, a `League` will create `Players` to participate in it.  These `Players` have methods on them that allow analysis.  

A `Player` has an `is_alive()` method that indicates whether a player has been eliminated. 
```python
winners = [player for player in league.PLAYERS if player.is_alive()]
```

To analyze the outcome of players who did not win, you can use the `elimination_week` method: 
```python
elimination_order = sorted(league.PLAYERS, key=lambda player: player.elimination_week())
```

# Strategies

During instantiation, each `Player` is randomly assigned a strategy for how to place their pick for each week.  The strategies are defined in `survivor_league.strategies`.  Each strategy is a class that has a `rank_teams` method that takes a list of `Game`s and a list of `Team`s not to pick and returns a sorted list of `Team`s.  This list that is returned is sorted from the best pick to the worst, based on the strategy's rules.  

To add a new strategy to the simulation, simply take the following steps:
1. define a new class for the strategy and place it in `survivor_league.strategies`.
1. ensure that this new class has a public `name` attribute. 
1. ensure that this new class has a public `rank_teams` method that takes two arguments, `games` and `ineligible_teams`. `games` is a list of `Game`s; `ineligible_teams` is a list of `Team`s.  This method must return a list of `Team`s such that each element of the list is one of the `Team`s in one of the `Game`s in `games` and such that each element of the list is not in `ineligible_teams`.  The teams must be sorted from best to worst, as a `Player` utilizing the strategy will choose the first element of the list as their pick for a given week. 
1. ensure that the new class is well tested. 

# Teams and Games

Each `Team` is assigned an elo rating during instantiation.  Each `Game` has a `home_team` and an `away_team`, each of type `Team`, and can use the elo ratings of each `Team` to determine the relative odds of victory. 

# simulate.py

I have included a script called `simulate.py` at the top level of this repository that uses Monte Carlo simulation to assess the relative odds of winning in one of these simulated survivor leagues using the strategies provided. 

# Future development

This simulator is very much a v1.  Ideas I have for future development, as of 12 November 2019, include: 
- more precise scheduling via the `ScheduleGenerator`.  Right now, the `ScheduleGenerator` works by randomly assigning byes to teams and then assigning the rest of the teams to games.  (In fact, I just noticed a bug in which this assignment of teams to games might not always be random, so fixing that might be a top priority). The schedule generated by the `ScheduleGenerator` class looks nothing like an NFL schedule. 
- better analysis methods on `League`.  For instance, it lacks a `winners` method and asks that end users calculate winners themselves. 
- week-by-week simulations.  Right now, simulating a season can only be done with the `League.simulate_season` method. 
- more week-to-week adjustments to the simulation.  Some teams get worse as the season goes on and some get better.  Other teams are impacted by injuries to important players.  Right now, the simulation assigns the same elo rating to a team for the duration of a season. 
- more repeatability.  Once a `League` has had `simulate_season` run on it once, it has no way of resetting itself. 
- allowing more precise user specification in `League`. Right now, a user could create their own `Schedule` and use that in a `League`, but cannot specify the `Player`s in a `League`, so the strategies they use are determined by the code. 
- better harnessing of randomness.  Looking at some of the sequences in which `Player`s are assigned strategies, it does not visibly look random.  Bunches of consecutively-created players are usually assigned the same strategy.
- of course, additional strategies for `Player`s to use. 
